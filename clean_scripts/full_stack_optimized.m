% =========================================================================
% full_stack_optimized.m
%
% Einzel Lens Simulation using Differential Algebra (DA) and DoPri8(7) Integration
% MODIFIED FOR BASIN-HOPPING OPTIMIZATION of 6 voltage parameters.
% =========================================================================
% This script simulates particle trajectories through an Einzel lens system
% including a 90-degree quadrupole bender section.
% It uses:
% 1. BEM for electrostatic fields in straight sections.
% 2. Pre-calculated segmented DA maps for the quadrupole bender.
% 3. Differential Algebra (DA) to represent particle state and potential/maps.
% 4. Dormand-Prince 8(7) (DoPri8(7)) to integrate the DA map through straight sections.
% 5. Basin-hopping optimization to find optimal voltages for specific electrodes.
% 6. Sequential evaluation of DA maps for ray tracing through the combined system.
%
% Dependencies:
% - MATLAB Global Optimization Toolbox (for `basin`)
% - DiffAlg class, Electrode class, BEM_monopole, axial_potential, ...
% - run_dopri87_da_integration, integrate_dopri87_da, dopri87_step_da, get_dopri87_coeffs
% - trace_ray_fan_multisegment_da_map
% - generate_lens_trajectory_stl, stlwrite
% - bender_segmented_data.mat (Generated by modified quadrupole_bender_tracer.m)
% - optimize_lens_objective.m (Objective function, defined below or separately)

set(0,'DefaultFigureWindowStyle','docked')
clear; clc; % Clear workspace, close figures

fprintf('--- Full Stack Simulation with Optimization ---\n');

% ================================================
% SECTION 1: Simulation Setup & Fixed Parameters
% ================================================
fprintf('\n--- Setting up Simulation Parameters ---\n');

% --- Basic Simulation Parameters ---
simParams.res = 2;      % Resolution for electrode boundary discretization (higher -> more accurate BEM)
simParams.spacing = 1;    % Spacing between electrodes
simParams.z0 = 0;         % Starting z position for the first electrode
simParams.R = 1;          % Inner radius of the tube electrodes (used in geometry definitions)

% --- Differential Algebra & Integration Parameters ---
daParams.daOrder = 3;       % DA order (higher -> more accurate map, slower calculation)
daParams.nVars = 2;         % Number of variables (r, p_r)
daParams.q_charge = 1.0;    % Particle charge
daParams.m_mass = 1.0;      % Particle mass
daParams.E0 = 0.6;          % Initial Kinetic Energy (reference for potential energy U=qV-E0)

% --- Overall Simulation Range ---
% These define the full extent for DA integration
dopriParams.z_start_overall = 32.5; % Overall start z for simulation
dopriParams.z_end_overall = 437;    % Overall end z for simulation

% --- Integrator Options (for DoPri8(7)) ---
integratorOpts = struct();
integratorOpts.RelTol = 1e-7;   % Relative tolerance
integratorOpts.AbsTol = 1e-10;  % Absolute tolerance
integratorOpts.Stats = 'off';   % Turn off stats per integration step ('on' for detailed output)
integratorOpts.MaxStep = 1.0;   % Max step size allowed by integrator
integratorOpts.MinStep = 1e-6;  % Min step size allowed by integrator
integratorOpts.PreallocateSteps = 1000; % Preallocate storage inside integrator

% --- Ray Tracing Parameters (for objective function evaluation) ---
traceParams.num_r_rays = 3;         % Number of rays in position (odd number recommended)
traceParams.num_s_rays = 3;         % Number of rays in slope (odd number recommended)
traceParams.max_r0_dev = 0.1;       % Max deviation in r from center_r0
traceParams.max_s0_dev = 0.01;      % Max deviation in p_r from center_s0
traceParams.center_r0 = 0.0;        % Central starting r position
traceParams.center_s0 = 0.0;        % Central starting p_r slope
traceParams.trace_eval_order = daParams.daOrder; % DA order for evaluation

% --- Electrode Geometry Definition ---
fprintf('Defining electrode geometry...\n');
BENDER_PLACEHOLDER_LEN = 0.5 * 43 * pi + 7.95*2; % Placeholder length, will be checked against loaded data later
tt = 2.0; pt = 4.0; % Decelerator dimensions
ids = {15.5, 20, 17, 16, 6, 32}; ls  = {33.0, 46, 12, 12, 6, 26}; ts  = {33 + 3, 46 + 3, 12 + 3,  12 + 3, 6 + 3, 26 + 3}; % Decelerator dimensions

electrodeData = {
    struct('thickness', 12, 'shape', @(res) ETH_endcap(res))            % 1: Inj. Endcap
    struct('thickness', 12, 'shape', @(res) ETH_profile(res))           % 2: Inj. Tube 1
    struct('thickness', 12, 'shape', @(res) ETH_profile(res))           % 3: Inj. Tube 2
    struct('thickness', 12, 'shape', @(res) ETH_profile(res))           % 4: Inj. Tube 3
    struct('thickness', 12, 'shape', @(res) ETH_profile(res))           % 5: Inj. Tube 4
    struct('thickness', 24, 'shape', @(res) ashfold_steer_tube(res))    % 6: Steerer 1
    struct('thickness', 12, 'shape', @(res) ashfold_empty_tube(res))    % 7: Einzel 1 Center (el1) <--- OPTIMIZED
    struct('thickness', 12, 'shape', @(res) ETH_endcap_right(res))      % 8: Einzel 1 End
    {'space', BENDER_PLACEHOLDER_LEN}                                   % 9: Bender Placeholder Space
    struct('thickness', 12, 'shape', @(res) ETH_endcap(res))            % 10: Einzel 2 Start
    struct('thickness', 12, 'shape', @(res) ashfold_empty_tube(res))    % 11: Einzel 2 Center (el2) <--- OPTIMIZED
    struct('thickness', 24, 'shape', @(res) ashfold_steer_tube(res))    % 12: Steerer 2
    struct('thickness', 12, 'shape', @(res) ETH_endcap_right(res))      % 13: Decel Start/Einzel 2 End
    {'space', 26.3}                                                     % 14: Space before Decel
    struct('thickness', ts{1}, 'shape', @(res) tube_in_plate(ids{1}, tt, ls{1}, pt, 37.5, res)) % 15: Decel 1 (dl1) <--- OPTIMIZED
    struct('thickness', ts{2}, 'shape', @(res) tube_in_plate(ids{2}, tt, ls{2}, pt, 37.5, res)) % 16: Decel 2 (dl2) <--- OPTIMIZED
    struct('thickness', ts{3}, 'shape', @(res) tube_in_plate(ids{3}, tt, ls{3}, pt, 37.5, res)) % 17: Decel 3 (dl3) <--- OPTIMIZED
    struct('thickness', ts{4}, 'shape', @(res) tube_in_plate(ids{4}, tt, ls{4}, pt, 37.5, res)) % 18: Decel 4 (dl4) <--- OPTIMIZED
    struct('thickness', ts{5}, 'shape', @(res) tube_in_plate(ids{5}, tt, ls{5}, pt, 37.5, res)) % 19: Decel 5
    struct('thickness', ts{6}, 'shape', @(res) tube_in_plate(ids{6}, tt, ls{6}, pt, 37.5, res)) % 20: Decel 6
    struct('thickness', 8, 'shape', @(res) tube_in_plate(3, 0.5, 6, 2, 37.5, res))              % 21: Final Endcap
};

% --- Fixed Voltage Parameters ---
% These voltages are NOT optimized
Vs_fixed_values = [1.0; 0.8; 0.6; 0.4; 0.2; ...  % 1-5: Injection Tube Gradient
                   0.0; ...
                   0.0; ...
                   % Bender space (9) has no voltage index
                   0.0; ...
                   0.0; ...
                   0.0; ...
                   % Space (14) has no voltage index
                   0.0; ...
                   0.0; ...
                   0.0; ...
                  ];
% Indices corresponding to the fixed voltages above in the final Vs vector
Vs_fixed_indices = [1:6, 8, 9, 11, 12, 17, 18, 19]; % Adjust indices based on actual electrode count
opt_indices = [7, 10, 13:16];
n_opt_params = length(opt_indices);

% --- Load Bender Segmented Data ---
fprintf('Loading pre-calculated segmented bender data...\n');
bender_segmented_data_file = 'MAT007_clean_DA/bender_segmented_data.mat';
try
    loaded_data = load(bender_segmented_data_file, 'transfer_maps', 'ref_states', 'z_coords');
    transfer_maps_bender_lin = loaded_data.transfer_maps; % Linear maps
    ref_states_bender = loaded_data.ref_states;
    z_coords_bender_rel = loaded_data.z_coords; % Relative z coords within bender
    fprintf('  Loaded transfer_maps, ref_states, z_coords.\n');
    n_bender_segments = numel(transfer_maps_bender_lin);
    if n_bender_segments == 0, error('Loaded bender data has no segments.'); end
    bender_length_loaded = z_coords_bender_rel(end) - z_coords_bender_rel(1);
    fprintf('  Bender length from loaded z_coords: %.6f\n', bender_length_loaded);
    % Check consistency
    if abs(bender_length_loaded - BENDER_PLACEHOLDER_LEN) > 1e-3
        warning('Loaded bender length (%.4f) differs significantly from placeholder length (%.4f). Using loaded length.', bender_length_loaded, BENDER_PLACEHOLDER_LEN);
    end
catch ME_load
    fprintf('Error loading %s: %s\n', bender_segmented_data_file, ME_load.message);
    error('Could not load necessary segmented bender data.');
end

% --- Update Electrode Data with Loaded Bender Length & Create Stack ---
fprintf('Updating electrodeData with loaded bender length...\n');
bender_idx = -1;
for idx = 1:length(electrodeData)
    if iscell(electrodeData{idx}) && strcmpi(electrodeData{idx}{1}, 'space') && idx == 9 % Target the 9th element specifically
        bender_idx = idx;
        electrodeData{idx}{2} = bender_length_loaded; % Update length
        fprintf('  Updated electrodeData item %d (bender space) with loaded length %.6f\n', idx, bender_length_loaded);
        break;
    end
end
if bender_idx == -1, error("Could not find the {'space', ...} element for the bender (expected at index 9)."); end

opts_stack = struct('z0', simParams.z0, 'spacing', simParams.spacing, 'res', simParams.res);
fprintf('Building FULL electrode stack (including bender space)...\n');
[electrodes_full_stack, z_boundaries_elements] = createElectrodeStack(electrodeData, opts_stack);
n_electrodes_total = numel(electrodes_full_stack); % Number of electrode objects (excluding spaces)
fprintf('Full electrode stack created (%d electrode objects, %d boundaries).\n', n_electrodes_total, numel(z_boundaries_elements));

% Check if number of fixed voltage indices matches structure
if numel(Vs_fixed_indices) ~= numel(Vs_fixed_values)
    error('Mismatch between Vs_fixed_indices (%d) and Vs_fixed_values (%d).', numel(Vs_fixed_indices), numel(Vs_fixed_values));
end
if max(Vs_fixed_indices) > n_electrodes_total
     error('Vs_fixed_indices contains indices larger than the number of electrodes (%d).', n_electrodes_total);
end


% ================================================
% SECTION 2: BEM Calculation (Performed Once)
% ================================================
fprintf('\n--- Performing BEM Calculation ---\n');
% Run BEM on the full stack (spaces are ignored by BEM_monopole)
[qs, bemTable_full] = BEM_monopole(electrodes_full_stack, 1.0, false); % Verbose off
fprintf('BEM analysis complete. qs matrix size: %d x %d\n', size(qs, 1), size(qs, 2));

% Check consistency: number of rows in qs should match number of electrodes
if size(qs, 1) ~= n_electrodes_total
    error('BEM output size mismatch: qs has %d rows, expected %d (number of electrode objects).', size(qs, 1), n_electrodes_total);
end

% ================================================
% SECTION 3: Optimization Setup
% ================================================
fprintf('\n--- Setting up Optimization ---\n');

% --- Optimization Parameters ---
% Indices of voltages to optimize in the final Vs vector (based on electrodeData order)
% el1: Einzel 1 Center (electrode object 7)
% el2: Einzel 2 Center (electrode object 11)
% dl1: Decel 1         (electrode object 14)
% dl2: Decel 2         (electrode object 15)
% dl3: Decel 3         (electrode object 16)
% dl4: Decel 4         (electrode object 17)

% Check if opt_indices and Vs_fixed_indices cover all electrodes without overlap
all_indices = sort([Vs_fixed_indices(:); opt_indices(:)]);
if ~isequal(all_indices, (1:n_electrodes_total)') || numel(all_indices) ~= n_electrodes_total
    warning('Vs_fixed_indices and opt_indices do not perfectly partition all electrode indices (1 to %d). Check definitions.', n_electrodes_total);
    fprintf('Fixed Indices (%d): %s\n', numel(Vs_fixed_indices), mat2str(Vs_fixed_indices));
    fprintf('Opt Indices (%d): %s\n', numel(opt_indices), mat2str(opt_indices));
    fprintf('Union (%d): %s\n', numel(all_indices), mat2str(all_indices));
    % Allow proceeding but flag potential issue. Error out if overlap detected.
    if numel(unique(all_indices)) ~= numel(all_indices)
        error('Overlap detected between Vs_fixed_indices and opt_indices.');
    end
end


% Define initial guess for the 6 parameters
x0 = [0.3; 0.0; 0.1; 0.2; 0.3; 0.1];

% Define bounds
lb = zeros(n_opt_params, 1) - 5.0;   % Lower bound (Allow slightly negative for flexibility, adjust if needed)
ub = ones(n_opt_params, 1) * 0.5;   % Upper bound (0.5 as requested)

% --- Determine Bender Z-Range from Full Stack ---
% This needs to be robustly determined from the built geometry
fprintf('Determining bender z-range from stack boundaries...\n');
% Find indices corresponding to the start and end of the bender space
z_bend_start = z_boundaries_elements(bender_idx); % Z position AFTER electrode 8
z_bend_end = z_boundaries_elements(bender_idx + 1); % Z position AFTER the space (start of electrode 10)
fprintf('  Bender physical range: z = [%.4f, %.4f]\n', z_bend_start, z_bend_end);
% Adjust relative bender coordinates to absolute coordinates
z_coords_bender_abs = z_coords_bender_rel + z_bend_start;

% --- Construct Bender DA Map Sequence (ONCE) ---
fprintf('Constructing DA Map Sequence for Bender Section (Order %d)...\n', daParams.daOrder);
r_da = DiffAlg.var(1, daParams.daOrder, daParams.nVars);
pr_da = DiffAlg.var(2, daParams.daOrder, daParams.nVars);
one_da = DiffAlg.one(daParams.nVars, daParams.daOrder);
S_maps_bender_segmented = cell(1, n_bender_segments); % DA maps

for i = 1:n_bender_segments
    M_i = transfer_maps_bender_lin{i};  % 2x2 linear map for segment i
    X_ref_i = ref_states_bender(:, i); % Ref state [r; p] at START of segment i
    X_ref_f = ref_states_bender(:, i+1);% Ref state [r; p] at END of segment i
    Offset_i = X_ref_f - M_i * X_ref_i; % Constant offset O_i = Xf - M*Xi
    % Construct DA map: X_f = M_i * X_i + O_i
    r_map_i = r_da * M_i(1,1) + pr_da * M_i(1,2) + one_da * Offset_i(1);
    pr_map_i = r_da * M_i(2,1) + pr_da * M_i(2,2) + one_da * Offset_i(2);
    S_maps_bender_segmented{i} = {r_map_i, pr_map_i};
end
fprintf('Bender DA map sequence constructed.\n');


% --- Define Objective Function Handle ---
% Pass all necessary pre-calculated/fixed data to the objective function
objectiveFunction = @(x) optimize_lens_objective(x, qs, bemTable_full, daParams, dopriParams, integratorOpts, traceParams, electrodes_full_stack, S_maps_bender_segmented, z_coords_bender_abs, z_bend_start, z_bend_end, Vs_fixed_indices, Vs_fixed_values, opt_indices, n_electrodes_total);

% --- Basin-Hopping Setup ---
% Number of independent basin‐hopping starts
n_start_points = 20;                   

% Local solver options for fmincon
opts_fmincon = optimoptions('fmincon', ...
    'Algorithm',             'interior-point', ...    % robust, handles bounds
    'Display',               'iter',               ...
    'MaxIterations',         1000,                 ...
    'MaxFunctionEvaluations',1e5,                 ...
    'OptimalityTolerance',   1e-8,                 ...
    'StepTolerance',         1e-10,                ...
    'FiniteDifferenceType',  'central');

% Use fmincon as the local solver within basin-hopping
problem = createOptimProblem('fmincon', 'objective', objectiveFunction, ...
    'x0', x0, 'lb', lb, 'ub', ub, 'options', opts_fmincon);

% Basin‐hopping control parameters
basin_options = struct( ...
    'Temperature',            1.0,      ... % controls jump acceptance
    'MaxIterations',         200,      ... % total basin‐hopping steps
    'Display',               'iter',   ... % show progress
    'LocalSolverOptions',     opts_fmincon, ...
    'PerturbationMagnitude',  0.05);    % size of random displacement

% Create the basin‐hopping problem wrapper
% (assumes you have a "basin" function that accepts these inputs)
% problem               – created above via createOptimProblem
% n_start_points        – number of random restarts
% basin_options         – struct of basin‐hopping settings

% ================================================
% SECTION 4: Run Basin‐Hopping
% ================================================
fprintf('\n--- Starting Basin‐Hopping Optimization (%d starts) ---\n', n_start_points);

% Reset any persistent state in the objective
optimize_lens_objective('reset');

tic;
[x_optimal, fval_optimal] = basin(problem, n_start_points, basin_options);
opt_time = toc;

fprintf('\n--- Optimization Finished in %.1f s ---\n', opt_time);
fprintf('Optimal Voltages (el1, el2, dl1, dl2, dl3, dl4): [%s]\n', sprintf('%.5f ', x_optimal));
fprintf('Minimum StdDev Cost: %.6e\n', fval_optimal);

% ================================================
% SECTION 5: Post-Optimization Analysis (Optional)
% ================================================
fprintf('\n--- Running Simulation with Optimal Parameters for Visualization ---\n');

% 1. Construct Optimal Voltage Vector
Vs_optimal = zeros(n_electrodes_total, 1);
Vs_optimal(Vs_fixed_indices) = Vs_fixed_values;
Vs_optimal(opt_indices) = x_optimal;

% 2. Calculate qVs_optimal
bemParams_optimal.Vs = Vs_optimal;
bemParams_optimal.qVs = qs' * Vs_optimal;

% 3. Rerun Integrations
integratorOpts.Stats = 'off'; % Turn off detailed stats for visualization run
% Integration 1
[z_steps1_opt, S_steps1_opt, ~] = run_dopri87_da_integration(dopriParams1, daParams, bemParams_optimal, bemTable_full, integratorOpts);
integrationResults1_opt = struct('z_steps', z_steps1_opt, 'S_steps', {S_steps1_opt});
% Integration 2
[z_steps2_opt, S_steps2_opt, ~] = run_dopri87_da_integration(dopriParams2, daParams, bemParams_optimal, bemTable_full, integratorOpts);
integrationResults2_opt = struct('z_steps', z_steps2_opt, 'S_steps', {S_steps2_opt});

% 4. Rerun Ray Tracing
visParams.electrodes_full_stack = electrodes_full_stack;
visParams.simParams = simParams;
[~, ~, ~] = trace_ray_fan_multisegment_da_map(traceParams, ...
                                              integrationResults1_opt, ...
                                              S_maps_bender_segmented, ...
                                              z_coords_bender_abs, ...
                                              integrationResults2_opt, ...
                                              visParams, ...
                                              traceParams.trace_eval_order);
fprintf('Ray tracing with optimal parameters complete (Figure 2 updated).\n');
figure(2); % Bring ray trace figure to front
title(sprintf('Optimal Ray Fan (Order %d, Cost=%.3e)', daParams.daOrder, fval_optimal));

% 5. Plot Optimal Axial Potential
figure(1); clf;
potParams_opt.zs_plot = linspace(z_plot_min, z_plot_max, 1024);
potParams_opt.U_analytical = axial_potential(potParams_opt.zs_plot, bemParams_optimal.qVs, bemTable_full.r_center, bemTable_full.z_center);
plot(potParams_opt.zs_plot, potParams_opt.U_analytical, '-k', 'LineWidth', 1.5);
title('Optimal Axial Potential (Excluding Bender Region)'); xlabel('Axial Position z'); ylabel('Potential U(z)');
grid on; hold on;
xline([z_bend_start, z_bend_end], '--r', {'Bender Start', 'Bender End'});
ylim_curr = ylim; % Adjust y-axis if needed
text(dopriParams.z_start_overall, ylim_curr(2)*0.9, sprintf('Optimal Cost: %.4e', fval_optimal), 'VerticalAlignment', 'top');
hold off; drawnow;
fprintf('Optimal axial potential plotted (Figure 1 updated).\n');


disp('--- Full Script Finished ---');


% =========================================================================
%                            OBJECTIVE FUNCTION
% =========================================================================
function cost = optimize_lens_objective(x, qs, bemTable, daParams, dopriParams, integratorOpts, traceParams, electrodes_full_stack, S_maps_bender_segmented, z_coords_bender_abs, z_bend_start, z_bend_end, Vs_fixed_indices, Vs_fixed_values, opt_indices, n_electrodes_total)
% Objective function for basin-hopping optimization.
% Calculates the standard deviation of the final radial positions for a
% given set of input voltages 'x'.

    persistent best_cost iteration_count current_best_x % Use persistent vars to track best cost

    % Reset mechanism for persistent variables
    if ischar(x) && strcmp(x, 'reset')
        best_cost = Inf;
        iteration_count = 0;
        current_best_x = [];
        cost = 0; % Return dummy value
        return;
    end

    % Initialize on first call
    if isempty(iteration_count) || iteration_count < 0 % Check if reset needed or first run
        best_cost = Inf;
        iteration_count = 0;
        current_best_x = x(:); % Ensure column vector
    end
    iteration_count = iteration_count + 1;

    fprintf('\n--- Basin Iteration %d ---\n', iteration_count);
    fprintf('Current Params: [%s]\n', sprintf('%.6f ', x));

    % 1. Construct Full Voltage Vector
    Vs = zeros(n_electrodes_total, 1); % Initialize voltage vector
    Vs(Vs_fixed_indices) = Vs_fixed_values;
    Vs(opt_indices) = x(:); % Assign optimized values (ensure column)

    % 2. Calculate qVs
    bemParams.Vs = Vs;
    bemParams.qVs = qs' * Vs; % Note: qs is Nseg x Nelec, Vs is Nelec x 1, qVs is Nseg x 1

    cost = NaN; % Default cost if integration/tracing fails
    stdout_capture = evalc('run_integrations_and_trace(daParams, bemParams, bemTable, dopriParams, integratorOpts, traceParams, electrodes_full_stack, S_maps_bender_segmented, z_coords_bender_abs, z_bend_start, z_bend_end)'); % Capture stdout

    try
        % 3. Run DA Integrations & Ray Tracing
        % Wrap the integration and tracing logic into a sub-function or block
        [r_positions_combined, trace_valid] = run_integrations_and_trace(daParams, bemParams, bemTable, dopriParams, integratorOpts, traceParams, electrodes_full_stack, S_maps_bender_segmented, z_coords_bender_abs, z_bend_start, z_bend_end);

        if ~trace_valid || isempty(r_positions_combined)
             fprintf('  Tracing invalid or returned empty results.\n');
             cost = 1e10; % High cost for invalid trace
        else
            % 4. Calculate Cost (Standard Deviation of Final Radial Positions)
            final_r = r_positions_combined(end, :);
            valid_rays = ~isnan(final_r);
            if sum(valid_rays) < 2 % Need at least 2 valid rays
                cost = 1e9; % High cost if too few rays make it
                fprintf('  Cost (High - <2 valid final rays): %.4e\n', cost);
            else
                cost = std(final_r(valid_rays));
                if ~isfinite(cost) % Check if std dev calculation failed
                     fprintf('  Cost calculation resulted in non-finite value.\n');
                     cost = 1e11; % Very high cost
                else
                    fprintf('  Cost (Std Dev): %.6e\n', cost);
                end
            end
        end

    catch ME
        fprintf('!!! Error during objective function evaluation (Iter %d): %s\n', iteration_count, ME.message);
        fprintf('    Location: %s, Line: %d\n', ME.stack(1).name, ME.stack(1).line);
        cost = 1e12; % Assign a very large cost if any part fails
        fprintf('  Cost (High - Error): %.4e\n', cost);
    end

     % Update and display best cost found so far
    if isfinite(cost) && cost < best_cost
        best_cost = cost;
        current_best_x = x(:); % Ensure column
        fprintf('>>> New Best Cost Found: %.6e\n', best_cost);
        fprintf('    Best Params so far: [%s]\n', sprintf('%.6f ', current_best_x));
    elseif isfinite(best_cost)
         fprintf('    Best Cost Remains: %.6e\n', best_cost);
    else
         fprintf('    Best Cost is still Inf.\n');
    end
     fprintf('------------------------------\n');

     % --- Make sure cost is scalar double ---
     if ~isa(cost, 'double') || ~isscalar(cost)
         warning('Objective function returned non-scalar double. Attempting conversion.');
         try
             cost = double(cost(1));
             if ~isfinite(cost)
                 cost = 1e15; % Assign high value if conversion leads to NaN/Inf
             end
         catch
             cost = 1e15; % Assign high value if conversion fails
         end
     end
      % Ensure cost is not NaN/Inf for the optimizer
     if ~isfinite(cost)
         cost = 1e15; % Assign a large finite value
         fprintf('  Returning large finite cost (1e15) due to non-finite result.\n');
     end


end % End of optimize_lens_objective

function [r_positions_combined, trace_valid] = run_integrations_and_trace(daParams, bemParams, bemTable, dopriParams, integratorOpts, traceParams, electrodes_full_stack, S_maps_bender_segmented, z_coords_bender_abs, z_bend_start, z_bend_end)
    % Helper function to perform the integrations and tracing, returning results.
    r_positions_combined = []; % Initialize empty
    trace_valid = false;       % Initialize as invalid

    % Integration 1
    dopriParams1 = struct('z_start', dopriParams.z_start_overall, 'z_end', z_bend_start);
    [z_steps1, S_steps1, ~] = run_dopri87_da_integration(dopriParams1, daParams, bemParams, bemTable, integratorOpts);
    if isempty(z_steps1) || abs(z_steps1(end) - z_bend_start) > 1e-5
        fprintf('  Warning: Integration 1 failed or did not reach end.\n');
        return; % Exit helper function
    end
    integrationResults1 = struct('z_steps', z_steps1, 'S_steps', {S_steps1});

    % Integration 2
    dopriParams2 = struct('z_start', z_bend_end, 'z_end', dopriParams.z_end_overall);
    [z_steps2, S_steps2, ~] = run_dopri87_da_integration(dopriParams2, daParams, bemParams, bemTable, integratorOpts);
     if isempty(z_steps2) || abs(z_steps2(end) - dopriParams.z_end_overall) > 1e-5
        fprintf('  Warning: Integration 2 failed or did not reach end.\n');
        return; % Exit helper function
    end
    integrationResults2 = struct('z_steps', z_steps2, 'S_steps', {S_steps2});

    % Ray Tracing
    visParams.electrodes_full_stack = electrodes_full_stack;
    visParams.simParams = struct('R', 1); % Dummy simParams
    trace_eval_order = daParams.daOrder;

    [r_positions_combined, ~, ~] = trace_ray_fan_multisegment_da_map(traceParams, ...
        integrationResults1, S_maps_bender_segmented, z_coords_bender_abs, integrationResults2, ...
        visParams, trace_eval_order);

    trace_valid = true; % Mark as valid if tracing function completed

end % End of run_integrations_and_trace

function [xBest,fBest] = basin(problem, nStarts, opts)
% Simple basin‑hopping around fmincon
    x0     = problem.x0(:);
    lb     = problem.lb;
    ub     = problem.ub;
    fun    = problem.objective;
    T      = opts.Temperature;
    mag    = opts.PerturbationMagnitude;
    solOpts = opts.LocalSolverOptions;
    
    fBest = Inf;
    xBest = x0;
    
    for k = 1:nStarts
        % 1) random perturbation
        xTrial = xBest + mag*randn(size(x0));
        xTrial = min(max(xTrial, lb), ub);
        
        % 2) local minimization
        [xLoc,fLoc] = fmincon(fun, xTrial, [],[],[],[], lb, ub, [], solOpts);
        
        % 3) metropolis‐style acceptance
        if fLoc < fBest || rand < exp((fBest - fLoc)/T)
            xBest = xLoc;
            fBest = fLoc;
        end
        
        if strcmp(opts.Display,'iter')
            fprintf('Basin iter %3d: fLoc=%.3e, fBest=%.3e\n', k, fLoc, fBest);
        end
    end
end